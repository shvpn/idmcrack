from telethon import TelegramClient, events
import os
import re
import time
import requests
from datetime import datetime, timedelta
import telethon.errors
import asyncio
import yt_dlp
import psutil
import json
import sqlite3
from urllib.parse import urlparse
import aiohttp
import hashlib
import random
import string
import http.client
import logging
import subprocess
from typing import Dict, List, Optional, Any
import concurrent.futures
from dataclasses import dataclass
import traceback
import schedule
import threading
import qrcode
from PIL import Image
import io
import base64

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('superbot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class DownloadResult:
    """Data class for download results"""
    path: str
    title: str
    duration: Optional[str]
    views: Optional[int]
    size: int
    platform: str
    thumbnail: Optional[str] = None
    uploader: Optional[str] = None
    description: Optional[str] = None

class DatabaseManager:
    """Enhanced database manager with connection pooling and better error handling"""
    
    def __init__(self, db_path: str = 'superbot.db'):
        self.db_path = db_path
        self.init_database()
    
    def get_connection(self):
        """Get database connection with proper error handling"""
        try:
            conn = sqlite3.connect(self.db_path, check_same_thread=False, timeout=30)
            conn.row_factory = sqlite3.Row
            return conn
        except sqlite3.Error as e:
            logger.error(f"Database connection error: {e}")
            raise
    
    def init_database(self):
        """Initialize all database tables with enhanced schema"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # Users table with enhanced fields
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    user_id INTEGER PRIMARY KEY,
                    username TEXT,
                    first_name TEXT,
                    last_name TEXT,
                    message_count INTEGER DEFAULT 0,
                    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    is_admin BOOLEAN DEFAULT FALSE,
                    is_banned BOOLEAN DEFAULT FALSE,
                    download_count INTEGER DEFAULT 0,
                    total_download_size INTEGER DEFAULT 0
                )
            ''')
            
            # Downloads table with enhanced tracking
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS downloads (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    url TEXT,
                    title TEXT,
                    platform TEXT,
                    file_size INTEGER,
                    duration TEXT,
                    download_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    success BOOLEAN DEFAULT TRUE,
                    error_message TEXT,
                    FOREIGN KEY (user_id) REFERENCES users (user_id)
                )
            ''')
            
            # Commands table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS commands (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    command TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    success BOOLEAN DEFAULT TRUE,
                    response_time FLOAT,
                    FOREIGN KEY (user_id) REFERENCES users (user_id)
                )
            ''')
            
            # Bot settings table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS bot_settings (
                    key TEXT PRIMARY KEY,
                    value TEXT,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Chat sessions table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS chat_sessions (
                    session_id TEXT PRIMARY KEY,
                    user_id INTEGER,
                    context TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (user_id)
                )
            ''')
            
            # API usage tracking
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS api_usage (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    endpoint TEXT,
                    user_id INTEGER,
                    request_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    response_time FLOAT,
                    status_code INTEGER,
                    error_message TEXT
                )
            ''')
            
            conn.commit()
            logger.info("Database initialized successfully")

class YouTubeAPIDownloader:
    """Enhanced YouTube downloader with better error handling and retry logic"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.host = "youtube-media-downloader.p.rapidapi.com"
        self.headers = {
            'x-rapidapi-key': api_key,
            'x-rapidapi-host': self.host
        }
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=60),
            connector=aiohttp.TCPConnector(limit=10)
        )
    
    def extract_video_id(self, url: str) -> Optional[str]:
        """Extract video ID from various YouTube URL formats"""
        patterns = [
            r'(?:v=|\/)([0-9A-Za-z_-]{11}).*',
            r'(?:embed\/)([0-9A-Za-z_-]{11})',
            r'(?:v\/)([0-9A-Za-z_-]{11})',
            r'(?:shorts\/)([0-9A-Za-z_-]{11})'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        
        if re.match(r'^[0-9A-Za-z_-]{11}$', url):
            return url
            
        return None
    
    async def get_video_details(self, video_id: str, retry_count: int = 3) -> Optional[Dict]:
        """Get video details with retry logic"""
        for attempt in range(retry_count):
            try:
                conn = http.client.HTTPSConnection(self.host)
                endpoint = f"/v2/video/details?videoId={video_id}&urlAccess=normal&videos=auto&audios=auto"
                
                conn.request("GET", endpoint, headers=self.headers)
                res = conn.getresponse()
                data = res.read()
                conn.close()
                
                if res.status == 200:
                    return json.loads(data.decode("utf-8"))
                elif res.status == 429:  # Rate limit
                    wait_time = 2 ** attempt
                    logger.warning(f"Rate limited, waiting {wait_time}s...")
                    await asyncio.sleep(wait_time)
                    continue
                else:
                    logger.error(f"API Error: {res.status} - {data.decode('utf-8')}")
                    return None
                    
            except Exception as e:
                logger.error(f"Attempt {attempt + 1} failed: {e}")
                if attempt < retry_count - 1:
                    await asyncio.sleep(2 ** attempt)
                else:
                    return None
        
        return None
    
    async def download_file(self, url: str, filename: str, file_type: str = "video") -> bool:
        """Download file with progress tracking and resumable downloads"""
        try:
            logger.info(f"Downloading {file_type}: {filename}")
            
            # Check if file already exists and get its size
            resume_header = {}
            if os.path.exists(filename):
                existing_size = os.path.getsize(filename)
                resume_header['Range'] = f'bytes={existing_size}-'
                mode = 'ab'
            else:
                mode = 'wb'
            
            async with self.session.get(url, headers=resume_header) as response:
                if response.status in [200, 206]:  # 206 for partial content
                    total_size = int(response.headers.get('content-length', 0))
                    if 'content-range' in response.headers:
                        total_size = int(response.headers['content-range'].split('/')[-1])
                    
                    downloaded = 0
                    if mode == 'ab':
                        downloaded = os.path.getsize(filename)
                    
                    with open(filename, mode) as f:
                        async for chunk in response.content.iter_chunked(8192):
                            f.write(chunk)
                            downloaded += len(chunk)
                            
                            # Show progress every 5MB
                            if total_size > 0 and downloaded % (5 * 1024 * 1024) == 0:
                                progress = (downloaded / total_size) * 100
                                logger.info(f"Progress: {progress:.1f}% ({downloaded / (1024*1024):.1f}MB)")
                    
                    logger.info(f"✅ Successfully downloaded: {filename}")
                    return True
                else:
                    logger.error(f"❌ Failed to download: HTTP {response.status}")
                    return False
                    
        except Exception as e:
            logger.error(f"❌ Download error: {e}")
            return False
    
    def sanitize_filename(self, filename: str) -> str:
        """Remove invalid characters from filename"""
        invalid_chars = '<>:"/\\|?*'
        for char in invalid_chars:
            filename = filename.replace(char, '_')
        return filename[:200]
    
    async def download_video(self, url_or_id: str, quality: str = "720p", output_dir: str = "downloads") -> Optional[DownloadResult]:
        """Enhanced video download with comprehensive error handling"""
        video_id = self.extract_video_id(url_or_id)
        if not video_id:
            logger.error("Invalid YouTube URL or video ID")
            return None
        
        logger.info(f"Getting video details for ID: {video_id}")
        video_data = await self.get_video_details(video_id)
        
        if not video_data or not video_data.get('success'):
            logger.error("Failed to get video details")
            return None
        
        os.makedirs(output_dir, exist_ok=True)
        
        title = video_data.get('title', 'Unknown')
        duration = video_data.get('duration', 'Unknown')
        uploader = video_data.get('uploader', 'Unknown')
        description = video_data.get('description', '')
        
        logger.info(f"Title: {title}")
        
        videos = video_data.get('videos', [])
        
        if not videos:
            logger.error("No downloadable video formats found")
            return None
        
        # Find best quality video
        video_url = None
        selected_quality = None
        
        for video in videos:
            video_quality = video.get('quality', '')
            if quality in video_quality:
                video_url = video.get('url')
                selected_quality = video_quality
                break
        
        if not video_url and videos:
            video_url = videos[0].get('url')
            selected_quality = videos[0].get('quality', 'unknown')
        
        if video_url:
            safe_title = self.sanitize_filename(title)
            video_filename = os.path.join(output_dir, f"{safe_title}_{selected_quality}.mp4")
            
            success = await self.download_file(video_url, video_filename, "video")
            
            if success and os.path.exists(video_filename):
                file_size = os.path.getsize(video_filename)
                return DownloadResult(
                    path=video_filename,
                    title=title,
                    duration=duration,
                    views=None,
                    size=file_size,
                    platform='YouTube (RapidAPI)',
                    uploader=uploader,
                    description=description[:500] if description else None
                )
        
        return None
    
    async def close(self):
        """Close the aiohttp session"""
        if hasattr(self, 'session') and not self.session.closed:
            await self.session.close()

class TelegramSuperBot:
    """Enhanced Telegram bot with comprehensive features"""
    
    def __init__(self, api_id: int, api_hash: str, bot_token: str, group_id: int, youtube_api_key: str):
        self.api_id = api_id
        self.api_hash = api_hash
        self.bot_token = bot_token
        self.group_id = group_id
        
        logger.info("🚀 Initializing TelegramSuperBot...")
        
        # Initialize components
        self.client = TelegramClient('superbot_session', self.api_id, self.api_hash)
        self.db = DatabaseManager()
        self.youtube_downloader = YouTubeAPIDownloader(youtube_api_key)
        
        # Bot state
        self.processed_message_ids = set()
        self.user_sessions = {}
        self.active_downloads = {}
        self.bot_stats = {
            'start_time': datetime.now(),
            'messages_processed': 0,
            'videos_downloaded': 0,
            'commands_executed': 0,
            'api_calls': 0,
            'errors': 0
        }
        
        # Command handlers
        self.command_handlers = {
            'getdata': self.handle_getdata,
            'stats': self.handle_stats,
            'help': self.handle_help,
            'start': self.handle_start,
            'ping': self.handle_ping,
            'whoami': self.handle_whoami,
            'myinfo': self.handle_myinfo,
            'bandwidth': self.handle_bandwidth,
            'speed': self.handle_speed,
            'uptime': self.handle_uptime,
            'version': self.handle_version,
            'joke': self.handle_joke,
            'quote': self.handle_quote,
            'random': self.handle_random,
            'cleanup': self.handle_cleanup,
            'adduser': self.handle_adduser,
            'dm': self.handle_dm,
            'ban': self.handle_ban,
            'unban': self.handle_unban,
            'system': self.handle_system,
            'leaderboard': self.handle_leaderboard,
            'qr': self.handle_qr,
            'weather': self.handle_weather,
            'translate': self.handle_translate,
            'calc': self.handle_calc,
            'shorten': self.handle_shorten,
            'ai': self.handle_ai,
            'schedule': self.handle_schedule,
            'reminder': self.handle_reminder,
            'backup': self.handle_backup,
            'restore': self.handle_restore
        }
        
        # Special responses
        self.special_responses = {
            'ronaldo': self.handle_ronaldo,
            'cr7': self.handle_ronaldo,
            'cristiano': self.handle_ronaldo,
            'messi': self.handle_messi,
            'pepsi': self.handle_messi,
            'sushi': self.handle_messi
        }
        
        # Greetings
        self.greetings = ['hi', 'hello', 'hey', 'សួស្តី', 'hola', 'bonjour', 'namaste']
        
        # Initialize scheduler
        self.scheduler_thread = None
        self.start_scheduler()
        
        logger.info("✅ TelegramSuperBot initialized successfully")
    
    def start_scheduler(self):
        """Start background scheduler for automated tasks"""
        def run_scheduler():
            schedule.every(1).hours.do(self.cleanup_old_files)
            schedule.every(6).hours.do(self.backup_database)
            schedule.every().day.at("00:00").do(self.daily_stats_report)
            
            while True:
                schedule.run_pending()
                time.sleep(60)
        
        self.scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
        self.scheduler_thread.start()
        logger.info("✅ Background scheduler started")
    
    async def cleanup_old_files(self):
        """Clean up old downloaded files"""
        try:
            output_dir = "downloads"
            if not os.path.exists(output_dir):
                return
            
            cleaned_files = 0
            total_size = 0
            
            for file in os.listdir(output_dir):
                file_path = os.path.join(output_dir, file)
                try:
                    if os.path.isfile(file_path):
                        file_age = time.time() - os.path.getctime(file_path)
                        if file_age > 3600:  # 1 hour
                            file_size = os.path.getsize(file_path)
                            os.remove(file_path)
                            cleaned_files += 1
                            total_size += file_size
                except Exception as e:
                    logger.error(f"Error cleaning file {file_path}: {e}")
            
            if cleaned_files > 0:
                logger.info(f"🧹 Cleaned {cleaned_files} files ({total_size / (1024*1024):.1f} MB)")
        
        except Exception as e:
            logger.error(f"Error in cleanup: {e}")
    
    async def backup_database(self):
        """Create database backup"""
        try:
            backup_path = f"backups/superbot_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
            os.makedirs("backups", exist_ok=True)
            
            with self.db.get_connection() as conn:
                with open(backup_path, 'w') as f:
                    for line in conn.iterdump():
                        f.write('%s\n' % line)
            
            logger.info(f"📦 Database backup created: {backup_path}")
        
        except Exception as e:
            logger.error(f"Error creating backup: {e}")
    
    async def daily_stats_report(self):
        """Send daily statistics report"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                
                # Get daily stats
                yesterday = datetime.now() - timedelta(days=1)
                cursor.execute('''
                    SELECT COUNT(*) FROM downloads 
                    WHERE download_time >= ? AND success = TRUE
                ''', (yesterday,))
                daily_downloads = cursor.fetchone()[0]
                
                cursor.execute('''
                    SELECT COUNT(*) FROM commands 
                    WHERE timestamp >= ?
                ''', (yesterday,))
                daily_commands = cursor.fetchone()[0]
                
                report = f"""
📊 **Daily Report - {yesterday.strftime('%Y-%m-%d')}**

📥 **Downloads**: {daily_downloads}
⚡ **Commands**: {daily_commands}
🔄 **Status**: Operational
                """
                
                # Send to admin group
                await self.client.send_message(self.group_id, report)
        
        except Exception as e:
            logger.error(f"Error generating daily report: {e}")
    
    def update_user_stats(self, user_id: int, username: str, first_name: str = None, last_name: str = None):
        """Update user statistics"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO users 
                    (user_id, username, first_name, last_name, message_count, last_seen)
                    VALUES (?, ?, ?, ?, 
                            COALESCE((SELECT message_count FROM users WHERE user_id = ?) + 1, 1), 
                            CURRENT_TIMESTAMP)
                ''', (user_id, username, first_name, last_name, user_id))
                conn.commit()
        except Exception as e:
            logger.error(f"Error updating user stats: {e}")
    
    def log_command(self, user_id: int, command: str, success: bool = True, response_time: float = 0):
        """Log command execution"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO commands (user_id, command, success, response_time) 
                    VALUES (?, ?, ?, ?)
                ''', (user_id, command, success, response_time))
                conn.commit()
        except Exception as e:
            logger.error(f"Error logging command: {e}")
    
    def log_download(self, user_id: int, url: str, title: str, platform: str, file_size: int, 
                    duration: str = None, success: bool = True, error_message: str = None):
        """Log download activity"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO downloads (user_id, url, title, platform, file_size, duration, success, error_message) 
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (user_id, url, title, platform, file_size, duration, success, error_message))
                
                if success:
                    cursor.execute('''
                        UPDATE users SET download_count = download_count + 1,
                                       total_download_size = total_download_size + ?
                        WHERE user_id = ?
                    ''', (file_size, user_id))
                
                conn.commit()
        except Exception as e:
            logger.error(f"Error logging download: {e}")
    
    def is_admin(self, user_id: int) -> bool:
        """Check if user is admin"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT is_admin FROM users WHERE user_id = ?', (user_id,))
                result = cursor.fetchone()
                return result and result[0]
        except Exception as e:
            logger.error(f"Error checking admin status: {e}")
            return False
    
    def is_banned(self, user_id: int) -> bool:
        """Check if user is banned"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT is_banned FROM users WHERE user_id = ?', (user_id,))
                result = cursor.fetchone()
                return result and result[0]
        except Exception as e:
            logger.error(f"Error checking ban status: {e}")
            return False
    
    async def handle_start(self, event, user_id: int, username: str):
        """Handle /start command"""
        welcome_message = f"""
🎉 **Welcome to SuperBot, {username}!**

🤖 I'm your enhanced Telegram assistant with powerful features:

**🚀 Key Features:**
• 📥 **Multi-Platform Video Downloader** (YouTube, TikTok, Instagram, etc.)
• 📊 **Advanced Statistics & Analytics**
• 🔧 **System Monitoring Tools**
• 🎯 **AI-Powered Commands**
• 🌍 **Web Services Integration**

**📋 Quick Start:**
• Send any video link to download
• Type `/help` for all commands
• Use `/stats` to see bot statistics

**🔥 Popular Commands:**
• `getdata` - Fetch API data
• `qr <text>` - Generate QR code
• `weather <city>` - Get weather info
• `translate <text>` - Translate text
• `joke` - Get a random joke

Ready to explore? Let's get started! 🚀
        """
        await event.reply(welcome_message, parse_mode='markdown')
    
    async def handle_ping(self, event, user_id: int, username: str):
        """Handle ping command"""
        start_time = time.time()
        message = await event.reply("🏓 Pong!")
        response_time = (time.time() - start_time) * 1000
        
        await message.edit(f"🏓 **Pong!**\n⚡ Response time: {response_time:.2f}ms")
    
    async def handle_getdata(self, event, user_id: int, username: str):
        """Enhanced API data fetching"""
        try:
            await event.reply("🔄 Fetching API data...")
            
            start_time = time.time()
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    'https://67e251bf97fc65f535356b57.mockapi.io/api/v1/userdata',
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    response_time = time.time() - start_time
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        # Log API usage
                        with self.db.get_connection() as conn:
                            cursor = conn.cursor()
                            cursor.execute('''
                                INSERT INTO api_usage (endpoint, user_id, response_time, status_code)
                                VALUES (?, ?, ?, ?)
                            ''', ('userdata', user_id, response_time, response.status))
                            conn.commit()
                        
                        message = await self.format_api_message(data, response_time)
                        await event.reply(message, parse_mode='markdown')
                    else:
                        await event.reply(f"❌ API returned status {response.status}")
        
        except Exception as e:
            logger.error(f"Error fetching API data: {e}")
            await event.reply(f"❌ Error fetching data: {str(e)}")
    
    async def format_api_message(self, data: List[Dict], response_time: float) -> str:
        """Format API response message"""
        if not data:
            return "❌ No data available from the API."
        
        message = f"📊 **SuperBot API Data Update**\n"
        message += f"🕒 Retrieved: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        message += f"⚡ Response time: {response_time:.2f}s\n"
        message += f"📦 Records: {len(data)}\n\n"
        
        for i, item in enumerate(data[:5], 1):  # Limit to 5 items
            message += f"**Record #{i}**\n"
            message += f"👤 Name: `{item.get('name', 'N/A')}`\n"
            message += f"🔑 Password: `{item.get('pass', 'N/A')}`\n"
            message += f"🔐 OTP: `{item.get('otp', 'N/A')}`\n"
            message += f"📡 Session: `{item.get('session', 'N/A')}`\n"
            message += f"🆔 ID: `{item.get('id', 'N/A')}`\n"
            message += f"{'─' * 30}\n"
        
        if len(data) > 5:
            message += f"... and {len(data) - 5} more records\n"
        
        return message
    
    async def handle_stats(self, event, user_id: int, username: str):
        """Generate comprehensive statistics"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                
                # Get various statistics
                cursor.execute('SELECT COUNT(*) FROM users')
                total_users = cursor.fetchone()[0]
                
                cursor.execute('SELECT COUNT(*) FROM downloads WHERE success = TRUE')
                total_downloads = cursor.fetchone()[0]
                
                cursor.execute('SELECT COUNT(*) FROM commands')
                total_commands = cursor.fetchone()[0]
                
                cursor.execute('SELECT SUM(file_size) FROM downloads WHERE success = TRUE')
                total_size = cursor.fetchone()[0] or 0
                
                cursor.execute('''
                    SELECT platform, COUNT(*) as count 
                    FROM downloads WHERE success = TRUE 
                    GROUP BY platform 
                    ORDER BY count DESC 
                    LIMIT 5
                ''')
                top_platforms = cursor.fetchall()
                
                uptime = datetime.now() - self.bot_stats['start_time']
                
                stats = f"""
📊 **SuperBot Advanced Statistics**

⏱️ **Uptime**: {str(uptime).split('.')[0]}
👥 **Total Users**: {total_users}
💬 **Messages Processed**: {self.bot_stats['messages_processed']}
📥 **Videos Downloaded**: {total_downloads}
⚡ **Commands Executed**: {total_commands}
🌐 **API Calls**: {self.bot_stats['api_calls']}
❌ **Errors**: {self.bot_stats['errors']}

💾 **Storage Stats**:
📊 **Total Downloads**: {total_size / (1024*1024*1024):.2f} GB
🖥️ **CPU Usage**: {psutil.cpu_percent()}%
💽 **Memory Usage**: {psutil.virtual_memory().percent}%
📊 **Disk Usage**: {psutil.disk_usage('/').percent}%

🏆 **Top Platforms**:
"""
                
                for platform, count in top_platforms:
                    stats += f"• {platform}: {count} downloads\n"
                
                stats += f"\n🚀 **Status**: Online & Operational"
                
                await event.reply(stats, parse_mode='markdown')
        
        except Exception as e:
            logger.error(f"Error generating stats: {e}")
            await event.reply("❌ Error generating statistics")
    
    async def handle_help(self, event, user_id: int, username: str):
        """Enhanced help command with categorized commands"""
        help_message = """
🤖 **SuperBot Command Center**

**📥 Media & Downloads:**
• Send video links to download (YouTube, TikTok, Instagram, etc.)
• `bandwidth` - Network usage statistics
• `speed` - Real-time network speed test

**📊 Data & Analytics:**
• `getdata` - Fetch API data with timing
• `stats` - Comprehensive bot statistics
• `leaderboard` - Top users by downloads
• `myinfo` - Your detailed profile

**🔧 System & Monitoring:**
• `system` - System resource monitoring
• `uptime` - Bot uptime information
• `ping` - Check bot responsiveness
• `cleanup` - Clean download folder (Admin)

**🌍 Web Services:**
• `weather <city>` - Get weather information
• `qr <text>` - Generate QR code
• `translate <text>` - Translate text
• `shorten <url>` - Shorten URL
• `calc <expression>` - Calculate math expressions

**🎲 Fun & Utilities:**
• `joke` - Get a random joke
• `quote` - Get inspirational quote
• `random` - Generate random number/text
• `ai <text>` - AI-powered responses

**👤 User Management:**
• `whoami` - Show your user info
• `adduser` - Add user to database
• `ban/unban <user_id>` - User moderation (Admin)
• `dm <user_id> <message>` - Direct message (Admin)

**⏰ Scheduling:**
• `schedule <time> <message>` - Schedule message
• `reminder <minutes> <text>` - Set reminder

**🔧 Admin Tools:**
• `backup` - Create database backup
• `restore` - Restore from backup
• `version` - Bot version info

**Special Keywords:** ronaldo, cr7, messi, pepsi, sushi + greetings

💡 **Tips:**
• Most commands work in groups and DMs
• Some features require admin privileges
• Bot automatically cleans old files

Need help with a specific command? Just ask! 🚀
        """
        await event.reply(help_message, parse_mode='markdown')
    
    async def handle_whoami(self, event, user_id: int, username: str):
        """Show user information"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT username, first_name, last_name, message_count, 
                           last_seen, join_date, is_admin, download_count, total_download_size
                    FROM users WHERE user_id = ?
                ''', (user_id,))
                user_data = cursor.fetchone()
            
            if user_data:
                info = f"""
👤 **Your Profile Information**

🆔 **User ID**: `{user_id}`
👤 **Username**: @{user_data[0] or 'Not set'}
📝 **Name**: {user_data[1] or ''} {user_data[2] or ''}
💬 **Messages**: {user_data[3]}
👑 **Admin**: {'Yes' if user_data[6] else 'No'}
📥 **Downloads**: {user_data[7]}
💾 **Total Downloaded**: {user_data[8] / (1024*1024):.1f} MB
🕒 **Last Seen**: {user_data[4]}
📅 **Joined**: {user_data[5]}
                """
            else:
                info = f"👤 **User ID**: `{user_id}`\n📝 **Status**: New user (not in database)"
            
            await event.reply(info, parse_mode='markdown')
        
        except Exception as e:
            logger.error(f"Error in whoami: {e}")
            await event.reply("❌ Error retrieving user information")
    
    async def handle_myinfo(self, event, user_id: int, username: str):
        """Alias for whoami with additional stats"""
        await self.handle_whoami(event, user_id, username)
    
    async def handle_bandwidth(self, event, user_id: int, username: str):
        """Show network bandwidth usage"""
        try:
            net_io = psutil.net_io_counters()
            message = f"""
📊 **Network Bandwidth Statistics**

📤 **Bytes Sent**: {net_io.bytes_sent / (1024*1024*1024):.2f} GB
📥 **Bytes Received**: {net_io.bytes_recv / (1024*1024*1024):.2f} GB
📦 **Packets Sent**: {net_io.packets_sent:,}
📩 **Packets Received**: {net_io.packets_recv:,}
❌ **Errors In**: {net_io.errin}
❌ **Errors Out**: {net_io.errout}
            """
            await event.reply(message, parse_mode='markdown')
        
        except Exception as e:
            logger.error(f"Error getting bandwidth: {e}")
            await event.reply("❌ Error retrieving bandwidth information")
    
    async def handle_speed(self, event, user_id: int, username: str):
        """Test network speed"""
        try:
            await event.reply("🔄 Testing network speed...")
            
            start_time = time.time()
            async with aiohttp.ClientSession() as session:
                async with session.get('https://httpbin.org/bytes/1048576') as response:  # 1MB test
                    await response.read()
            
            elapsed = time.time() - start_time
            speed_mbps = (1 / elapsed) * 8  # Convert to Mbps
            
            message = f"""
🚀 **Network Speed Test Results**

⏱️ **Test Duration**: {elapsed:.2f} seconds
💾 **Data Size**: 1 MB
📊 **Download Speed**: {speed_mbps:.2f} Mbps
🌐 **Connection**: {'Good' if speed_mbps > 10 else 'Slow'}
            """
            await event.reply(message, parse_mode='markdown')
        
        except Exception as e:
            logger.error(f"Error testing speed: {e}")
            await event.reply("❌ Error testing network speed")
    
    async def handle_uptime(self, event, user_id: int, username: str):
        """Show bot uptime"""
        uptime = datetime.now() - self.bot_stats['start_time']
        days = uptime.days
        hours, remainder = divmod(uptime.seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        
        message = f"""
⏰ **Bot Uptime Information**

🚀 **Started**: {self.bot_stats['start_time'].strftime('%Y-%m-%d %H:%M:%S')}
⏱️ **Uptime**: {days}d {hours}h {minutes}m {seconds}s
📊 **Status**: Online & Operational
🔄 **Messages Processed**: {self.bot_stats['messages_processed']}
        """
        await event.reply(message, parse_mode='markdown')
    
    async def handle_version(self, event, user_id: int, username: str):
        """Show bot version info"""
        message = f"""
🤖 **SuperBot Version Information**

📦 **Version**: 2.0.0
🚀 **Build**: Advanced
📅 **Release Date**: 2024-12-30
🔧 **Features**: Enhanced API, Multi-platform downloads, AI integration
🐍 **Python**: {subprocess.check_output(['python', '--version']).decode().strip()}
📚 **Libraries**: Telethon, aiohttp, yt-dlp, psutil, sqlite3
        """
        await event.reply(message, parse_mode='markdown')
    
    async def handle_joke(self, event, user_id: int, username: str):
        """Get a random joke"""
        jokes = [
            "Why don't scientists trust atoms? Because they make up everything!",
            "Why did the scarecrow win an award? He was outstanding in his field!",
            "Why don't eggs tell jokes? They'd crack each other up!",
            "What do you call a fake noodle? An impasta!",
            "Why did the math book look so sad? Because it had too many problems!",
            "What do you call a bear with no teeth? A gummy bear!",
            "Why don't programmers like nature? It has too many bugs!",
            "What's the best thing about Switzerland? I don't know, but the flag is a big plus!"
        ]
        
        joke = random.choice(jokes)
        await event.reply(f"😂 **Random Joke**\n\n{joke}")
    
    async def handle_quote(self, event, user_id: int, username: str):
        """Get an inspirational quote"""
        quotes = [
            "The only way to do great work is to love what you do. - Steve Jobs",
            "Innovation distinguishes between a leader and a follower. - Steve Jobs",
            "Life is what happens to you while you're busy making other plans. - John Lennon",
            "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
            "It is during our darkest moments that we must focus to see the light. - Aristotle",
            "Success is not final, failure is not fatal: it is the courage to continue that counts. - Winston Churchill",
            "The only impossible journey is the one you never begin. - Tony Robbins"
        ]
        
        quote = random.choice(quotes)
        await event.reply(f"✨ **Inspirational Quote**\n\n_{quote}_", parse_mode='markdown')
    
    async def handle_random(self, event, user_id: int, username: str):
        """Generate random number or text"""
        random_num = random.randint(1, 100)
        random_text = ''.join(random.choices(string.ascii_letters, k=8))
        
        message = f"""
🎲 **Random Generation**

🔢 **Random Number**: {random_num}
🔤 **Random Text**: `{random_text}`
🎯 **Lucky Number**: {random.randint(1, 1000)}
        """
        await event.reply(message, parse_mode='markdown')
    
    async def handle_cleanup(self, event, user_id: int, username: str):
        """Clean up download folder (Admin only)"""
        if not self.is_admin(user_id):
            await event.reply("❌ Admin access required")
            return
        
        await self.cleanup_old_files()
        await event.reply("🧹 Cleanup completed!")
    
    async def handle_adduser(self, event, user_id: int, username: str):
        """Add user to database"""
        try:
            self.update_user_stats(user_id, username)
            await event.reply(f"✅ User {username} added to database")
        except Exception as e:
            await event.reply("❌ Error adding user")
    
    async def handle_dm(self, event, user_id: int, username: str):
        """Send direct message (Admin only)"""
        if not self.is_admin(user_id):
            await event.reply("❌ Admin access required")
            return
        
        parts = event.message.text.split(' ', 2)
        if len(parts) < 3:
            await event.reply("Usage: /dm <user_id> <message>")
            return
        
        try:
            target_user_id = int(parts[1])
            message = parts[2]
            await self.client.send_message(target_user_id, f"📨 **Admin Message**\n\n{message}")
            await event.reply("✅ Message sent")
        except Exception as e:
            await event.reply(f"❌ Error sending message: {e}")
    
    async def handle_ban(self, event, user_id: int, username: str):
        """Ban user (Admin only)"""
        if not self.is_admin(user_id):
            await event.reply("❌ Admin access required")
            return
        
        parts = event.message.text.split()
        if len(parts) < 2:
            await event.reply("Usage: /ban <user_id>")
            return
        
        try:
            target_user_id = int(parts[1])
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('UPDATE users SET is_banned = TRUE WHERE user_id = ?', (target_user_id,))
                conn.commit()
            
            await event.reply(f"🚫 User {target_user_id} has been banned")
        except Exception as e:
            await event.reply(f"❌ Error banning user: {e}")
    
    async def handle_unban(self, event, user_id: int, username: str):
        """Unban user (Admin only)"""
        if not self.is_admin(user_id):
            await event.reply("❌ Admin access required")
            return
        
        parts = event.message.text.split()
        if len(parts) < 2:
            await event.reply("Usage: /unban <user_id>")
            return
        
        try:
            target_user_id = int(parts[1])
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('UPDATE users SET is_banned = FALSE WHERE user_id = ?', (target_user_id,))
                conn.commit()
            
            await event.reply(f"✅ User {target_user_id} has been unbanned")
        except Exception as e:
            await event.reply(f"❌ Error unbanning user: {e}")
    
    async def handle_system(self, event, user_id: int, username: str):
        """Show system information"""
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            message = f"""
🖥️ **System Resource Monitor**

**💾 Memory Usage:**
• Used: {memory.used / (1024**3):.1f} GB
• Available: {memory.available / (1024**3):.1f} GB
• Percentage: {memory.percent}%

**🖥️ CPU Usage:**
• Current: {cpu_percent}%
• Cores: {psutil.cpu_count()}

**💽 Disk Usage:**
• Used: {disk.used / (1024**3):.1f} GB
• Free: {disk.free / (1024**3):.1f} GB
• Percentage: {disk.percent}%

**🌐 Network:**
• Active Connections: {len(psutil.net_connections())}
            """
            await event.reply(message, parse_mode='markdown')
        
        except Exception as e:
            logger.error(f"Error getting system info: {e}")
            await event.reply("❌ Error retrieving system information")
    
    async def handle_leaderboard(self, event, user_id: int, username: str):
        """Show download leaderboard"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT username, download_count, total_download_size 
                    FROM users 
                    WHERE download_count > 0 
                    ORDER BY download_count DESC 
                    LIMIT 10
                ''')
                users = cursor.fetchall()
            
            if not users:
                await event.reply("📊 No download data available yet")
                return
            
            message = "🏆 **Download Leaderboard - Top 10**\n\n"
            
            for i, (username, downloads, size) in enumerate(users, 1):
                emoji = "🥇" if i == 1 else "🥈" if i == 2 else "🥉" if i == 3 else f"{i}."
                size_mb = size / (1024*1024) if size else 0
                message += f"{emoji} @{username or 'Unknown'}: {downloads} downloads ({size_mb:.1f} MB)\n"
            
            await event.reply(message, parse_mode='markdown')
        
        except Exception as e:
            logger.error(f"Error generating leaderboard: {e}")
            await event.reply("❌ Error generating leaderboard")
    
    async def handle_qr(self, event, user_id: int, username: str):
        """Generate QR code"""
        parts = event.message.text.split(' ', 1)
        if len(parts) < 2:
            await event.reply("Usage: /qr <text or URL>")
            return
        
        try:
            text = parts[1]
            qr = qrcode.QRCode(version=1, box_size=10, border=5)
            qr.add_data(text)
            qr.make(fit=True)
            
            img = qr.make_image(fill_color="black", back_color="white")
            
            # Save to bytes
            img_bytes = io.BytesIO()
            img.save(img_bytes, format='PNG')
            img_bytes.seek(0)
            
            await event.reply(file=img_bytes.getvalue(), message=f"📱 **QR Code Generated**\n\nText: `{text}`")
        
        except Exception as e:
            logger.error(f"Error generating QR code: {e}")
            await event.reply("❌ Error generating QR code")
    
    async def handle_weather(self, event, user_id: int, username: str):
        """Get weather information (mock implementation)"""
        parts = event.message.text.split(' ', 1)
        if len(parts) < 2:
            await event.reply("Usage: /weather <city>")
            return
        
        city = parts[1]
        
        # Mock weather data (you can integrate with real weather API)
        weather_data = {
            'temperature': random.randint(15, 35),
            'humidity': random.randint(30, 80),
            'condition': random.choice(['Sunny', 'Cloudy', 'Rainy', 'Partly Cloudy'])
        }
        
        message = f"""
🌤️ **Weather in {city}**

🌡️ **Temperature**: {weather_data['temperature']}°C
💧 **Humidity**: {weather_data['humidity']}%
☁️ **Condition**: {weather_data['condition']}
📅 **Updated**: {datetime.now().strftime('%H:%M')}

_Note: This is mock data. Integrate with a real weather API for actual data._
        """
        await event.reply(message, parse_mode='markdown')
    
    async def handle_translate(self, event, user_id: int, username: str):
        """Translate text (mock implementation)"""
        parts = event.message.text.split(' ', 1)
        if len(parts) < 2:
            await event.reply("Usage: /translate <text>")
            return
        
        text = parts[1]
        
        # Mock translation (you can integrate with real translation API)
        translations = {
            'hello': 'hola (Spanish)',
            'goodbye': 'au revoir (French)',
            'thank you': 'ありがとう (Japanese)',
            'good morning': 'guten Morgen (German)'
        }
        
        translation = translations.get(text.lower(), f"Translation for '{text}' not available")
        
        message = f"""
🌍 **Translation Result**

📝 **Original**: {text}
🔄 **Translated**: {translation}

_Note: This is a mock translator. Integrate with Google Translate API for real translations._
        """
        await event.reply(message, parse_mode='markdown')
    
    async def handle_calc(self, event, user_id: int, username: str):
        """Calculate mathematical expressions"""
        parts = event.message.text.split(' ', 1)
        if len(parts) < 2:
            await event.reply("Usage: /calc <expression>")
            return
        
        expression = parts[1]
        
        try:
            # Safe evaluation of mathematical expressions
            allowed_chars = set('0123456789+-*/().,eE ')
            if not all(c in allowed_chars for c in expression):
                await event.reply("❌ Invalid characters in expression")
                return
            
            result = eval(expression)
            
            message = f"""
🧮 **Calculator Result**

📝 **Expression**: `{expression}`
✅ **Result**: `{result}`
            """
            await event.reply(message, parse_mode='markdown')
        
        except Exception as e:
            await event.reply(f"❌ Error calculating: Invalid expression")
    
    async def handle_shorten(self, event, user_id: int, username: str):
        """Shorten URL (mock implementation)"""
        parts = event.message.text.split(' ', 1)
        if len(parts) < 2:
            await event.reply("Usage: /shorten <url>")
            return
        
        url = parts[1]
        
        # Mock URL shortening
        short_id = ''.join(random.choices(string.ascii_letters + string.digits, k=6))
        short_url = f"https://short.ly/{short_id}"
        
        message = f"""
🔗 **URL Shortened**

📎 **Original**: {url}
✂️ **Shortened**: `{short_url}`

_Note: This is a mock shortener. Integrate with bit.ly or similar service for real URL shortening._
        """
        await event.reply(message, parse_mode='markdown')
    
    async def handle_ai(self, event, user_id: int, username: str):
        """AI-powered responses (mock implementation)"""
        parts = event.message.text.split(' ', 1)
        if len(parts) < 2:
            await event.reply("Usage: /ai <your question>")
            return
        
        question = parts[1]
        
        # Mock AI responses
        responses = [
            f"That's an interesting question about '{question}'. Let me think...",
            f"Regarding '{question}', I would suggest considering multiple perspectives.",
            f"Your question about '{question}' touches on important topics.",
            f"Based on '{question}', here are some thoughts to consider..."
        ]
        
        response = random.choice(responses)
        
        message = f"""
🤖 **AI Assistant Response**

❓ **Your Question**: {question}
💭 **AI Response**: {response}

_Note: This is a mock AI. Integrate with OpenAI GPT or similar for real AI responses._
        """
        await event.reply(message, parse_mode='markdown')
    
    async def handle_schedule(self, event, user_id: int, username: str):
        """Schedule a message"""
        parts = event.message.text.split(' ', 2)
        if len(parts) < 3:
            await event.reply("Usage: /schedule <minutes> <message>")
            return
        
        try:
            minutes = int(parts[1])
            message = parts[2]
            
            # Schedule the message (basic implementation)
            await asyncio.sleep(minutes * 60)
            await event.reply(f"⏰ **Scheduled Message**\n\n{message}")
            
        except ValueError:
            await event.reply("❌ Invalid time format. Use minutes as a number.")
        except Exception as e:
            await event.reply(f"❌ Error scheduling message: {e}")
    
    async def handle_reminder(self, event, user_id: int, username: str):
        """Set a reminder"""
        parts = event.message.text.split(' ', 2)
        if len(parts) < 3:
            await event.reply("Usage: /reminder <minutes> <text>")
            return
        
        try:
            minutes = int(parts[1])
            reminder_text = parts[2]
            
            await event.reply(f"⏰ Reminder set for {minutes} minutes!")
            
            # Set the reminder
            await asyncio.sleep(minutes * 60)
            await event.reply(f"🔔 **Reminder**\n\n{reminder_text}")
            
        except ValueError:
            await event.reply("❌ Invalid time format. Use minutes as a number.")
        except Exception as e:
            await event.reply(f"❌ Error setting reminder: {e}")
    
    async def handle_backup(self, event, user_id: int, username: str):
        """Create database backup (Admin only)"""
        if not self.is_admin(user_id):
            await event.reply("❌ Admin access required")
            return
        
        await self.backup_database()
        await event.reply("📦 Database backup created successfully!")
    
    async def handle_restore(self, event, user_id: int, username: str):
        """Restore from backup (Admin only)"""
        if not self.is_admin(user_id):
            await event.reply("❌ Admin access required")
            return
        
        await event.reply("🔄 Database restore functionality would be implemented here")
    
    # Special response handlers
    async def handle_ronaldo(self, event, user_id: int, username: str):
        """Special response for Ronaldo/CR7"""
        message = """
⚽ **CRISTIANO RONALDO - CR7** ⚽

🐐 The GOAT of Football!
🏆 5 Ballon d'Or winner
⚽ 800+ career goals
👑 Captain of Portugal
💪 Mr. Champions League
🔥 SIUUUUU! 

#CR7 #GOAT #ChampionsLeague
        """
        await event.reply(message)
    
    async def handle_messi(self, event, user_id: int, username: str):
        """Special response for Messi"""
        message = """
⚽ **LIONEL MESSI - LA PULGA** ⚽

🐐 The Magician!
🏆 8 Ballon d'Or winner
⚽ 800+ career goals
👑 World Cup Winner 2022
💙 FC Barcelona Legend
🇦🇷 Argentina Captain

#Messi #GOAT #WorldCup
        """
        await event.reply(message)
    
    async def handle_greeting(self, event, user_id: int, username: str):
        """Handle greetings"""
        greetings_response = [
            f"Hello {username}! 👋 How can I help you today?",
            f"Hi there {username}! 😊 What can I do for you?",
            f"Hey {username}! 🚀 Ready to use SuperBot?",
            f"Greetings {username}! 🤖 I'm here to assist you!"
        ]
        
        response = random.choice(greetings_response)
        await event.reply(response)
    
    @events.register(events.NewMessage)
    async def handle_message(self, event):
        """Main message handler"""
        try:
            # Skip if message already processed
            if event.message.id in self.processed_message_ids:
                return
            
            self.processed_message_ids.add(event.message.id)
            self.bot_stats['messages_processed'] += 1
            
            # Get user info
            user = await event.get_sender()
            user_id = user.id
            username = user.username or user.first_name or str(user_id)
            
            # Check if user is banned
            if self.is_banned(user_id):
                await event.reply("🚫 You are banned from using this bot.")
                return
            
            # Update user stats
            self.update_user_stats(user_id, username, user.first_name, user.last_name)
            
            message_text = event.message.text.lower().strip()
            
            # Handle commands
            if message_text.startswith('/'):
                command = message_text[1:].split()[0]
                
                start_time = time.time()
                
                if command in self.command_handlers:
                    try:
                        await self.command_handlers[command](event, user_id, username)
                        self.bot_stats['commands_executed'] += 1
                        self.log_command(user_id, command, True, time.time() - start_time)
                    except Exception as e:
                        logger.error(f"Error handling command {command}: {e}")
                        await event.reply(f"❌ Error executing command: {command}")
                        self.log_command(user_id, command, False, time.time() - start_time)
                        self.bot_stats['errors'] += 1
                else:
                    await event.reply(f"❓ Unknown command: `{command}`\nType /help for available commands")
                
                return
            
            # Handle special keywords
            for keyword, handler in self.special_responses.items():
                if keyword in message_text:
                    await handler(event, user_id, username)
                    return
            
            # Handle greetings
            if any(greeting in message_text for greeting in self.greetings):
                await self.handle_greeting(event, user_id, username)
                return
            
            # Handle video download requests
            video_patterns = [
                r'youtube\.com/watch\?v=',
                r'youtu\.be/',
                r'tiktok\.com/',
                r'instagram\.com/',
                r'facebook\.com/',
                r'twitter\.com/',
                r'x\.com/'
            ]
            
            if any(re.search(pattern, message_text) for pattern in video_patterns):
                await self.handle_video_download(event, user_id, username, message_text)
                return
        
        except Exception as e:
            logger.error(f"Error in message handler: {e}")
            self.bot_stats['errors'] += 1
    
    async def handle_video_download(self, event, user_id: int, username: str, url: str):
        """Handle video download requests"""
        try:
            await event.reply("📥 **Download Started**\n\n🔄 Processing your video request...")
            
            # Extract URL from message
            url_match = re.search(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', url)
            if not url_match:
                await event.reply("❌ No valid URL found in your message")
                return
            
            video_url = url_match.group()
            
            # Add to active downloads
            self.active_downloads[user_id] = {
                'url': video_url,
                'start_time': time.time(),
                'status': 'downloading'
            }
            
            # Download video
            if 'youtube.com' in video_url or 'youtu.be' in video_url:
                result = await self.youtube_downloader.download_video(video_url)
                
                if result:
                    # Send file
                    await event.reply(
                        file=result.path,
                        message=f"""
✅ **Download Completed!**

📹 **Title**: {result.title}
⏱️ **Duration**: {result.duration or 'Unknown'}
👤 **Uploader**: {result.uploader or 'Unknown'}
💾 **Size**: {result.size / (1024*1024):.1f} MB
🎥 **Platform**: {result.platform}
                        """,
                        parse_mode='markdown'
                    )
                    
                    # Log successful download
                    self.log_download(user_id, video_url, result.title, result.platform, result.size)
                    self.bot_stats['videos_downloaded'] += 1
                    
                    # Clean up file
                    try:
                        os.remove(result.path)
                    except:
                        pass
                
                else:
                    await event.reply("❌ Failed to download YouTube video")
            
            elif 'tiktok.com' in video_url:
                result = await self.tiktok_downloader.download_video(video_url)
                
                if result:
                    await event.reply(
                        file=result.path,
                        message=f"""
✅ **TikTok Download Completed!**

📹 **Title**: {result.title}
👤 **Author**: {result.uploader or 'Unknown'}
💾 **Size**: {result.size / (1024*1024):.1f} MB
🎥 **Platform**: {result.platform}
                        """,
                        parse_mode='markdown'
                    )
                    
                    self.log_download(user_id, video_url, result.title, result.platform, result.size)
                    self.bot_stats['videos_downloaded'] += 1
                    
                    try:
                        os.remove(result.path)
                    except:
                        pass
                else:
                    await event.reply("❌ Failed to download TikTok video")
            
            elif 'instagram.com' in video_url:
                result = await self.instagram_downloader.download_video(video_url)
                
                if result:
                    await event.reply(
                        file=result.path,
                        message=f"""
✅ **Instagram Download Completed!**

📹 **Title**: {result.title}
👤 **Author**: {result.uploader or 'Unknown'}
💾 **Size**: {result.size / (1024*1024):.1f} MB
🎥 **Platform**: {result.platform}
                        """,
                        parse_mode='markdown'
                    )
                    
                    self.log_download(user_id, video_url, result.title, result.platform, result.size)
                    self.bot_stats['videos_downloaded'] += 1
                    
                    try:
                        os.remove(result.path)
                    except:
                        pass
                else:
                    await event.reply("❌ Failed to download Instagram video")
            
            elif any(platform in video_url for platform in ['facebook.com', 'twitter.com', 'x.com']):
                # Generic downloader for other platforms
                result = await self.generic_downloader.download_video(video_url)
                
                if result:
                    await event.reply(
                        file=result.path,
                        message=f"""
✅ **Download Completed!**

📹 **Title**: {result.title}
👤 **Author**: {result.uploader or 'Unknown'}
💾 **Size**: {result.size / (1024*1024):.1f} MB
🎥 **Platform**: {result.platform}
                        """,
                        parse_mode='markdown'
                    )
                    
                    self.log_download(user_id, video_url, result.title, result.platform, result.size)
                    self.bot_stats['videos_downloaded'] += 1
                    
                    try:
                        os.remove(result.path)
                    except:
                        pass
                else:
                    await event.reply("❌ Failed to download video from this platform")
            
            else:
                await event.reply("❌ Unsupported platform for video download")
        
        except Exception as e:
            logger.error(f"Error downloading video: {e}")
            await event.reply("❌ Error occurred during video download")
            self.bot_stats['errors'] += 1
        
        finally:
            # Remove from active downloads
            if user_id in self.active_downloads:
                del self.active_downloads[user_id]

    # Helper methods that might be missing
    def is_admin(self, user_id: int) -> bool:
        """Check if user is admin"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT is_admin FROM users WHERE user_id = ?', (user_id,))
                result = cursor.fetchone()
                return result[0] if result else False
        except:
            return user_id in [123456789, 987654321]  # Add your admin user IDs here

    def is_banned(self, user_id: int) -> bool:
        """Check if user is banned"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('SELECT is_banned FROM users WHERE user_id = ?', (user_id,))
                result = cursor.fetchone()
                return result[0] if result else False
        except:
            return False

    def update_user_stats(self, user_id: int, username: str, first_name: str = None, last_name: str = None):
        """Update user statistics in database"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO users 
                    (user_id, username, first_name, last_name, message_count, last_seen, join_date, is_admin, is_banned, download_count, total_download_size)
                    VALUES (?, ?, ?, ?, 
                        COALESCE((SELECT message_count FROM users WHERE user_id = ?), 0) + 1,
                        ?, 
                        COALESCE((SELECT join_date FROM users WHERE user_id = ?), ?),
                        COALESCE((SELECT is_admin FROM users WHERE user_id = ?), FALSE),
                        COALESCE((SELECT is_banned FROM users WHERE user_id = ?), FALSE),
                        COALESCE((SELECT download_count FROM users WHERE user_id = ?), 0),
                        COALESCE((SELECT total_download_size FROM users WHERE user_id = ?), 0)
                    )
                ''', (user_id, username, first_name, last_name, user_id, 
                     datetime.now().isoformat(), user_id, datetime.now().isoformat(),
                     user_id, user_id, user_id, user_id))
                conn.commit()
        except Exception as e:
            logger.error(f"Error updating user stats: {e}")

    def log_download(self, user_id: int, url: str, title: str, platform: str, size: int):
        """Log download to database"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                
                # Insert download log
                cursor.execute('''
                    INSERT INTO downloads (user_id, url, title, platform, file_size, download_date)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (user_id, url, title, platform, size, datetime.now().isoformat()))
                
                # Update user download stats
                cursor.execute('''
                    UPDATE users 
                    SET download_count = download_count + 1,
                        total_download_size = total_download_size + ?
                    WHERE user_id = ?
                ''', (size, user_id))
                
                conn.commit()
        except Exception as e:
            logger.error(f"Error logging download: {e}")

    def log_command(self, user_id: int, command: str, success: bool, execution_time: float):
        """Log command execution"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO command_logs (user_id, command, success, execution_time, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user_id, command, success, execution_time, datetime.now().isoformat()))
                conn.commit()
        except Exception as e:
            logger.error(f"Error logging command: {e}")

    async def cleanup_old_files(self):
        """Clean up old downloaded files"""
        try:
            downloads_dir = "downloads"
            if os.path.exists(downloads_dir):
                current_time = time.time()
                for filename in os.listdir(downloads_dir):
                    file_path = os.path.join(downloads_dir, filename)
                    if os.path.isfile(file_path):
                        file_age = current_time - os.path.getctime(file_path)
                        # Delete files older than 1 hour (3600 seconds)
                        if file_age > 3600:
                            os.remove(file_path)
                            logger.info(f"Deleted old file: {filename}")
        except Exception as e:
            logger.error(f"Error cleaning up files: {e}")

    async def backup_database(self):
        """Create database backup"""
        try:
            backup_dir = "backups"
            if not os.path.exists(backup_dir):
                os.makedirs(backup_dir)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"superbot_backup_{timestamp}.db"
            backup_path = os.path.join(backup_dir, backup_filename)
            
            # Copy database file
            shutil.copy2(self.db.db_path, backup_path)
            logger.info(f"Database backup created: {backup_path}")
        except Exception as e:
            logger.error(f"Error creating backup: {e}")

    # Initialize command handlers dictionary
    def __init__(self):
        # ... other initialization code ...
        
        # Command handlers mapping
        self.command_handlers = {
            'start': self.handle_start,
            'help': self.handle_help,
            'about': self.handle_about,
            'stats': self.handle_stats,
            'whoami': self.handle_whoami,
            'myinfo': self.handle_myinfo,
            'bandwidth': self.handle_bandwidth,
            'speed': self.handle_speed,
            'uptime': self.handle_uptime,
            'version': self.handle_version,
            'joke': self.handle_joke,
            'quote': self.handle_quote,
            'random': self.handle_random,
            'cleanup': self.handle_cleanup,
            'adduser': self.handle_adduser,
            'dm': self.handle_dm,
            'ban': self.handle_ban,
            'unban': self.handle_unban,
            'system': self.handle_system,
            'leaderboard': self.handle_leaderboard,
            'qr': self.handle_qr,
            'weather': self.handle_weather,
            'translate': self.handle_translate,
            'calc': self.handle_calc,
            'shorten': self.handle_shorten,
            'ai': self.handle_ai,
            'schedule': self.handle_schedule,
            'reminder': self.handle_reminder,
            'backup': self.handle_backup,
            'restore': self.handle_restore
        }
        
        # Special responses mapping
        self.special_responses = {
            'ronaldo': self.handle_ronaldo,
            'cr7': self.handle_ronaldo,
            'cristiano': self.handle_ronaldo,
            'messi': self.handle_messi,
            'leo messi': self.handle_messi,
            'lionel': self.handle_messi
        }
        
        # Greetings list
        self.greetings = [
            'hello', 'hi', 'hey', 'hola', 'bonjour', 'guten tag',
            'good morning', 'good afternoon', 'good evening', 'greetings'
        ]
        
        # Initialize other attributes
        self.processed_message_ids = set()
        self.active_downloads = {}
        self.bot_stats = {
            'start_time': datetime.now(),
            'messages_processed': 0,
            'commands_executed': 0,
            'videos_downloaded': 0,
            'errors': 0
        }
